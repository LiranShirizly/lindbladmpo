#######################
LindbladMPOSolver class
#######################

The LindbladMPOSolver class is the python interface of the solver. By calling the 'solve' function, a run configuration file is created and the c++ solver is initiated using the created file as an input.

class parameters
________________

The parameters of the class are passed to it in it's initialization. it accepts 3 parameters:

* s_cygwin_path (str): The cygwin executable path for the C++ execution. relevant only when running of Windows. has a default value of "C:/cygwin64/bin/bash.exe".
* s_solver_path (str): The path of the compiled C++ solver executable file. has a default value of '/../bin/lindbladmpo'.
* parameters (dict): The simulation model parameters. for more information see below.

model parameters
________________

All the model parameters are passed through the parameters' dict in class init function. For convenience, they are split into groups:

* basic parameters:
    * :math:`N` (int): The number of qubits in the lattice. This solver requires :math:`N >2`.
    * t_final (float): The final simulation time (:math:`t_f`).
    * t_init = 0 (float): The initial simulation time (:math:`t_0`). Must obey :math:`t_0 \le t_f`. Has default value of 0.
    * :math:`tau` (float): The discrete time step :math:`tau` used in the time evolution.
    * output_files_prefix = "lindblad" (str): The path and file name prefix to be used for the input file generated for the solver, as well as output files generated by the solver. Has default value of saving in the working directory with file prefix of "lindblad". if only directory path is given, "lindblad" file prefix will be used.
    * b_unique_id = False (bool): If True, a unique id will be generated for the simulation and appended to all generated file name prefixes. Has default value of False.
* Hamiltonian coefficients:
    * h_x = 0 (float): The :math:`h_{x,i}` coefficient in the Hamiltonian. If a vector is given, it specifies :math:`h_{x,i}` for each qubit. If a scalar is given, it is uniform for all qubits. Has default value of 0.
    * h_y = 0 (float): The :math:`h_{y,i}` coefficient in the Hamiltonian. If a vector is given, it specifies :math:`h_{y,i}` for each qubit. If a scalar is given, it is uniform for all qubits. Has default value of 0.
    * h_z = 0 (float): The :math:`h_{z,i}` coefficient in the Hamiltonian. If a vector is given, it specifies :math:`h_{z,i}` for each qubit. If a scalar is given, it is uniform for all qubits. Has default value of 0.
    * J_z = 0 (float): The :math:`J^z_{ij}` coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies :math:`J^z_{ij}` for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of :math:`J` or :math:`J_z` is a matrix, then the other one must be either a matrix as well, or 0. Has default value of 0.
    * J = 0 (float): The :math:`J_{ij}` coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies :math:`J_{ij}` for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of :math:`J` or :math:`J_z` is a matrix, then the other one must be either a matrix as well, or 0. Has default value of 0.
* Dissipation coefficients:
    * g_0 = 0 (float): The :math:`g_{0,i}` coefficient in the Lindbladian. If a vector is given, it specifies :math:`g_{0,i}` for each qubit. If a scalar is given, it is uniform for all qubits. Has default value of 0.
    * g_1 = 0 (float): The :math:`g_{1,i}` coefficient in the Lindbladian. If a vector is given, it specifies :math:`g_{1,i}` for each qubit. If a scalar is given, it is uniform for all qubits. Has default value of 0.
    * g_2 = 0 (float): The :math:`g_{2,i}` coefficient in the Lindbladian. If a vector is given, it specifies :math:`g_{2,i}` for each qubit. If a scalar is given, it is uniform for all qubits. Has default value of 0.
* Initial state:
    The initial state of the simulator is either a pure Pauli product state or a saved internal state from previous simulator runs.
    In the case of a pure Pauli stat, the 'init_Pauli_state' parameter should be used, while in the case of saved internal state the 'load_files_prefix parameter should be used. only one of those parameters should be used and the other should be empty.

    * init_Pauli_state = "+z" (list[str]): A length-N vector of two-character strings of the form :math:`\pm a`. Each string indicates the initial state of qubit :math:`i`. The initial state will be :math:`\rho(t_0) = |\psi_0\rangle\langle \psi_0|, \qquad |\psi_0\rangle = \prod_i |\pm a_i\rangle` while the given :math:`\pm a` a Pauli eigenstate: :math:`\sigma_i^a|\pm a_i\rangle = \pm |\pm a_i\rangle`. A single such string is also allowed, which will result in an identical initial state for all qubits. Has default value of "+z".
    * load_files_prefix = "" (str): The prefix of files as previously saved using the simulator, which the initial state has to be loaded from. An empty string indicates that the initial state is not loaded. See the parameter "b_save_final_state" for more details on the saved files. Has default value of empty string (not used).
* Lattice specification:
    * l_x = 0 (float): The length of the lattice along the x dimension (:math:`l_x`). In case of value 0, the number of qubits :math:`N` is used, and parameter l_y must be 1. Has default value of 0.
    * l_y = 1 (float): The length of the lattice along the y dimension (:math:`l_y`).
    * b_periodic_x = False (bool): Whether periodic boundary conditions are applied along the :math:`x` dimension. If True, then l_y must be 1. If False, open boundary conditions are used along the :math:`x` dimension. Has default value of False.
    * b_periodic_y = False (bool): Whether periodic boundary conditions are applied along the :math:`y` dimension. If False, open boundary conditions are used along the :math:`y` dimension. Has default value of False.
* Numerical simulation control:
    * Trotter_order = 4 (int): Trotter approximation order, Possible values are 2, 3, 4. Has default value of 4.
    * max_dim_rho = 400 (int): Maximum bond dimension for density matrices. Has default value of 400.
    * cut_off_rho = 1e-16 (float): Maximum truncation error (discarded Schmidt weight) for density matrices. Has default value of 1e-16.
    * b_force_rho_trace = True (bool): Whether to force the density matrix trace to one by substituting :math:`\rho \to\rho/ {\rm tr}\{\rho\}` at every time step, compensating for finite-step errors. Has default value of True.
    * force_rho_Hermitian_step = 4 (int): Determines every how many evolution time steps (:math:`\tau`), to substitute :math:`\rho \to (\rho + \rho^\dagger)/2`. This may reduce some errors, but is computationally expensive. Has default value of 4.
    * b_initial_rho_compression = True (bool): Whether a density matrix that is loaded from a previously saved state, should be re-gauged and compressed. Has no effect if the initial state is not loaded from a previously saved state. Has default value of True.
* Observables and output:
    * 1q_indices = [] (list[int]): A list of integers that specify the qubits which single-qubit observables will be calculated for. In the case of empty list, single-qubit observables will be calculated for all qubits. Has default value of empty list.
    * 1q_components = ['Z'] (list[str]): A list of strings that specify the Pauli observables to compute for all qubits given in parameter "1q_indices". Each string in the list must contain a subset of "x,y,z" (lower or upper case). The observable of a given Pauli :math:`sigma^a` on qubit :math:`i` at time :math:`t_k` is of the form :math:`\left\langle \sigma_i^a\right (t_k)\rangle`. The observables results are saved using a file name ending with "obs-1q.dat". Has default value of ['Z'].
    * 2q_indices = [] (list[tuple(int)]): A list of integer tuples that specify the qubit pairs for calculating two-qubit correlators. In the case of empty list, two-qubit correlators will  be calculated for all qubit pairs. Has default value of empty list.
    * 2q_components = ['ZZ'] (list[str]): A list of strings that specify the two-qubit Pauli observables to compute for all qubit pairs given in parameter "2q_indices". Each string in the list must contain a subset of "xx,yy,zz,xy,xz,yz,yx,zx,zy" (lower or upper case). The observable of a given Pauli pair :math:`sigma^a` and :math:`sigma^b` will have the form :math:`\left\langle \sigma_{i}^a(t_k) \sigma_{j}^b(t_k) \right\rangle`.  The observables results are saved using a file name ending with ".obs-2q.dat". Has default value of ['ZZ'].
    * output_step = 1 (int): How often (in discrete steps of time :math:`tau`) the observables are computed. In case of value 0, no observables will be computed. Has default value of 1.
    * b_save_final_state = False (bool): Whether to save the final state to files (Three binary files will be saved, whose names will have the prefix defined in "output_files_prefix"). Has default value of False.

class attributes
________________

* LindbladMPOSolver.parameters: Returns the dict of model parameters
* LindbladMPOSolver.s_input_file: Returns the path to the configuration file created for the c++ solver
* LindbladMPOSolver.s_output_path: Returns the path to the output files
* LindbladMPOSolver.s_cygwin_path: Returns the path to the cygwin executable used by the solver
* LindbladMPOSolver.s_solver_path: Returns the path to the compiled C++ solver executable file
* LindbladMPOSolver.s_id_suffix: Returns the solver instance unique id
* LindbladMPOSolver.result: Returns dict of dicts with the outputs of the solver at all the time steps which an observable was computed. The first dict will contain the one-qubit observable results, the second dict will contain the two-qubit observable results and the third dict will contain global results - the trace of the density matrix, the second RÂ´enyi entropy (:math:`-\ln{\rm tr }\{\rho^2\}`) and the operator space entanglement entropy (OSEE) for a bipartition at the central bond.

class methods
_____________

* solve(): Executing the C++ solver and saving the results in "result" attribute
* process_default_paths(s_cygwin_path (str), s_solver_path (str) -> (str, str): Returns the cygwin and solver paths according to the system platform. keeps them unchanged if given as input.
* build(parameters (dict)): Write the model parameters dictionary to the configuration file for the c++ solver. also initializes the s_input_file, s_output_prefix and s_id_suffix attributes according to the given model parameters.
* execute(s_cygwin_path (str), s_solver_path (str), s_input_file (str)) -> int: Executing the C++ solver and returning it's c++ exit code
* load_output(s_output_path (str)) -> dict: Read the solver output files and returns a dictionary with these results