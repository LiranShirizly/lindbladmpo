# LindbladMPOSolver class

The `LindbladMPOSolver` class is the Python interface of the solver. By calling the `solve()` method, an input configuration file is created and the C++ solver is initiated using the created file as an input.

## Class parameters

The parameters of the class are passed in its initialization (as parameters of the constructor). It accepts 3 parameters:

* s_cygwin_path (str): The cygwin executable path for the C++ execution. Relevant only when running under Windows, the default value is "C:/cygwin64/bin/bash.exe".
* s_solver_path (str): The path of the compiled C++ solver executable file. It has a default value '/../bin/lindbladmpo'.
* parameters (dict): The simulation model parameters. For more information see below.

## Model parameters

All the model parameters are passed through the parameters dictionary in the class init function. For convenience, they are listed below by groups.

The default value for each parameter is indicated with an equality sign (only the first three parameters below have no default value and must be specified when the solver is invoked using the Python interface).

* Basic parameters:
    * N (int): The number of qubits in the lattice. This solver requires <img src="https://render.githubusercontent.com/render/math?math=N \geq 2" style="vertical-align:bottom">.
    * t_final (float): The final simulation time (<img src="https://render.githubusercontent.com/render/math?math=t_f" align=middle>).
    * tau (float): The discrete time step <img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom"> used in the time evolution.
    * t_init = 0 (float): The initial simulation time (<img src="https://render.githubusercontent.com/render/math?math=t_0" align=middle>). Must obey <img src="https://render.githubusercontent.com/render/math?math=t_0 \le t_f" align=middle>.
    * output_files_prefix = "lindblad" (str): The path and file name prefix to be used for the input file generated for the solver, as well as output files generated by the solver. The default value indicates saving files in the working directory with the file name prefix "lindblad". If only a directory path is given, the "lindblad" file name prefix will be added.
    * b_unique_id = False (bool): If True, a unique id will be generated for the simulation and appended to all generated file name prefixes.
* Hamiltonian coefficients:
    * h_x = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{x,i}" > coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{x,i}" style="vertical-align:middle"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * h_y = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{y,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{y,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * h_z = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{z,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{z,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * J_z = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=J^z_{ij}" style="vertical-align:bottom"> coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=J^z_{ij}" style="vertical-align:bottom"> for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of <img src="https://render.githubusercontent.com/render/math?math=J" style="vertical-align:bottom"> or <img src="https://render.githubusercontent.com/render/math?math=J_z" style="vertical-align:bottom"> is a matrix, then the other one must be either a matrix as well, or 0.
    * J = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=J_{ij}" style="vertical-align:bottom"> coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=J_{ij}" style="vertical-align:bottom"> for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of <img src="https://render.githubusercontent.com/render/math?math=J" style="vertical-align:bottom"> or <img src="https://render.githubusercontent.com/render/math?math=J_z" style="vertical-align:bottom"> is a matrix, then the other one must be either a matrix as well, or 0.
* Dissipation coefficients:
    * g_0 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{0,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{0,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * g_1 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{1,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{1,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * g_2 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{2,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{2,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
* Initial state:
    The initial state of the simulator is either a pure Pauli product state, a graph state (defined by specifying a set <img src="https://render.githubusercontent.com/render/math?math=V" style="vertical-align:bottom"> of pairs of qubits, to all of which a controlled-Z gate is applied, after initializing all qubits along the positive <img src="https://render.githubusercontent.com/render/math?math=x" style="vertical-align:bottom"> axis) or a saved internal state (possibly mixed) from previous simulator runs.
    In the case of a pure Pauli product state, the 'init_pauli_state' parameter should be used, in the case of a graph state, the 'init_graph_state' parameter should be used and in the case of a saved internal state the 'load_files_prefix' parameter should be used. For each simulation, only one of those parameters should be used and the others should be left empty or at their default value.

    * init_pauli_state = "+z" (list[str]): A length-N vector of two-character strings of the form <img src="https://render.githubusercontent.com/render/math?math=\pm a" style="vertical-align:bottom">. Each string indicates the initial state of qubit <img src="https://render.githubusercontent.com/render/math?math=i" style="vertical-align:bottom">. The initial state will be

      <img src="https://render.githubusercontent.com/render/math?math=\rho(t_0) = \left|\psi_0\rangle\langle \psi_0\right|,\qquad \left|\psi_0\rangle = \prod_i \right|\pm a_i\rangle" style="vertical-align:bottom">,

      with <img src="https://render.githubusercontent.com/render/math?math=\pm a" style="vertical-align:bottom"> defining a Pauli eigenstate;

      <img src="https://render.githubusercontent.com/render/math?math=\sigma_i^a\left|\pm a_i\rangle = \pm \right|\pm a_i\rangle." style="vertical-align:bottom">

      A single such string is also allowed, which results in an identical initial state for all qubits.
    * init_graph_state = []. A list of integer tuples that specify the qubit pairs for performing a controlled-Z gate on, to generate an initial graph state (starting with all qubits pointing along the +x axis). The qubit pairs will represent j and k in the graph state formula;

      <img src="https://render.githubusercontent.com/render/math?math=\left|\psi_0\rangle=%20\prod_{(j,k)\in%20V}{CZ}[j,k]%20\prod_i%20\right|%2b%20x_i\rangle" style="vertical-align:bottom">.
    * load_files_prefix = "" (str): The prefix of files as previously saved using the simulator, which the initial state has to be loaded from. An empty string indicates that the initial state is not loaded. See the parameter "b_save_final_state" for more details on the saved files.
* Lattice specification:
    * l_x = 0 (float): The length of the lattice along the x dimension. In case of value 0, the number of qubits <img src="https://render.githubusercontent.com/render/math?math=N" style="vertical-align:bottom"> is used, and parameter l_y must be 1.
    * l_y = 1 (float): The length of the lattice along the y dimension.
    * b_periodic_x = False (bool): Whether periodic boundary conditions are applied along the x dimension. If True, then l_y must be 1. If False, open boundary conditions are used along the x dimension.
    * b_periodic_y = False (bool): Whether periodic boundary conditions are applied along the y dimension. If False, open boundary conditions are used along the y dimension.
* Numerical simulation control:
    * trotter_order = 4 (int): Trotter approximation order, Possible values are 2, 3, 4.
    * max_dim_rho = 400 (int): Maximum bond dimension for density matrices.
    * cut_off_rho = 1e-16 (float): Maximum truncation error (discarded Schmidt weight) for density matrices. The actual truncation is done using the most severe condition between cut_off_rho and max_dim_rho.
    * b_force_rho_trace = True (bool): Whether to force the density matrix trace to one by substituting <img src="https://render.githubusercontent.com/render/math?math=\rho \to\rho/ {\rm tr}\{\rho\}" style="vertical-align:bottom"> at every time step, compensating for some finite-step errors.
    * force_rho_hermitian_step = 4 (int): Determines every how many evolution time steps (<img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom">), to substitute <img src="https://render.githubusercontent.com/render/math?math=\rho \to (\rho %2b \rho^\dagger)/2" style="vertical-align:bottom">. This may reduce some errors, but is computationally expensive.
    * b_initial_rho_compression = True (bool): Whether a density matrix that is loaded from a previously saved state, should be re-gauged and compressed. Has no effect if the initial state is not loaded from a previously saved state.
* Observables and output:
    * 1q_indices = [] (list[int]): A list of integers that specify the qubits for which single-qubit observables will be calculated. In the case of an empty list, single-qubit observables will be calculated for all qubits.
    * 1q_components = ['Z'] (list[str]): A list of strings that specify the Pauli observables to compute for all qubits given in parameter "1q_indices". The allowed strings in the list are "x", "y", or "z" (lower or upper case). The observables results are saved using a file name ending with "obs-1q.dat".
    * 2q_indices = [] (list[tuple(int)]): A list of integer tuples that specify the qubit pairs for calculating two-qubit expectation values. In the case of an empty list, two-qubit expectation values will be calculated for all qubit pairs.
    * 2q_components = ['ZZ'] (list[str]): A list of strings that specify the two-qubit Pauli observables to compute for all qubit pairs given in parameter "2q_indices". The allowed strings in the list are one of "xx", "yy", "zz", "xy", "xz", "yz", "yx", "zx", "zy" (lower or upper case). The observables results are saved using a file name ending with ".obs-2q.dat".
    * output_step = 1 (int): How often (in integer steps of time <img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom">) the observables are computed. In case of the value 0, no observables will be computed.
    * b_save_final_state = False (bool): Whether to save the final state to files (Three binary files will be saved, whose names will have the prefix defined in "output_files_prefix").

## Class attributes

* LindbladMPOSolver.parameters: Returns the dict of model parameters.
* LindbladMPOSolver.s_input_file: Returns the path to the configuration file created for the C++ solver.
* LindbladMPOSolver.s_output_path: Returns the path to the output files.
* LindbladMPOSolver.s_cygwin_path: Returns the path to the cygwin executable used by the solver.
* LindbladMPOSolver.s_solver_path: Returns the path to the compiled C++ solver executable file.
* LindbladMPOSolver.s_id_suffix: Returns the solver instance unique id.
* LindbladMPOSolver.result: Returns the dictionary of results, described below.

## The result dictionary

 The result dictionary stores the outputs of the solver at all requested time steps, in three dictionaries whose keys are detailed in the following.
The stored data has a consistent format as detailed below.
* `obs-1q`. A dictionary for the one-qubit observables with the keys being
  a tuple with the format `(Pauli: str, qubit: tuple(int,))`. 
  The first key entry is the Pauli operator string (`x`, `y`, `z`),
  and the second key entry is a one-element tuple with the qubit number.
 Each value is a tuple, the first entry being a list with the times, and the second entry being the list of values of the observables at the indicated times.

* `obs-2q`. A dictionary for the two-qubit observables with the keys being a tuple with the format:
`(Pauli: str, qubit: tuple(int, int))`.
The first key entry is the Pauli operator string (`xx`, `xy`, etc.), and the second key entry is a two-element tuple with the two qubit numbers.
 Each value is a tuple, the first entry being a list with the times, and the second entry being the list of values of the observables at the indicated times.

* `global`. A dictionary for the global calculated quantities with the keys being a tuple with the format:
`(quantity: str, tuple())`.
The first key entry is the quantity string (`S_2`, `OSEE_center`, etc.), and the second key entry is an empty tuple.
 Each value is a tuple, the first entry being a list with the times, and the second entry being the list of values of the observables at the indicated times.


## Class methods

* solve(): Execute the C++ solver and saving the results in "result" attribute.
* process_default_paths(s_cygwin_path: str, s_solver_path: str) -> (str, str). Return the cygwin and solver paths according to the system platform. keeps them unchanged if given as input.
* build(parameters: dict). Write the model parameters dictionary to the input configuration file for the C++ solver. Also initializes the s_input_file, s_output_prefix and s_id_suffix attributes according to the given model parameters.
* execute(s_cygwin_path: str, s_solver_path: str, s_input_file: str) -> int. Execute the solver and return its exit code.
* load_output(s_output_path: str) -> dict. Read the solver output files and return a dictionary with the results.
