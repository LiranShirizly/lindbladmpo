# LindbladMPOSolver class

The `LindbladMPOSolver` class is the Python interface of the solver. By calling the `solve()` method, an input configuration file is created and the C++ solver is initiated using the created file as an input.

## Class parameters

The parameters of the class are passed to it in its initialization. It accepts 3 parameters:

* s_cygwin_path (str): The cygwin executable path for the C++ execution. Relevant only when running under Windows, the default value is "C:/cygwin64/bin/bash.exe".
* s_solver_path (str): The path of the compiled C++ solver executable file. It has a default value '/../bin/lindbladmpo'.
* parameters (dict): The simulation model parameters. For more information see below.

## Model parameters

All the model parameters are passed through the parameters dictionary in the class init function. For convenience, they are listed below by groups. The default value for each parameter is indicated with an equality sign (only the first three parameters below have no default value and must be specified when the solver is invoked using the Python interface).

* Basic parameters:
    * N (int): The number of qubits in the lattice. This solver requires <img src="https://render.githubusercontent.com/render/math?math=N >2" style="vertical-align:bottom">.
    * t_final (float): The final simulation time (<img src="https://render.githubusercontent.com/render/math?math=t_f" align=middle>).
    * tau (float): The discrete time step <img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom"> used in the time evolution.
    * t_init = 0 (float): The initial simulation time (<img src="https://render.githubusercontent.com/render/math?math=$t_0$" style="vertical-align:bottom">). Must obey <img src="https://render.githubusercontent.com/render/math?math=t_0 \le t_f" align=middle>.
    * output_files_prefix = "lindblad" (str): The path and file name prefix to be used for the input file generated for the solver, as well as output files generated by the solver. The default value indicates saving files in the working directory with the file name prefix "lindblad". If only directory path is given, the "lindblad" prefix will be added.
    * b_unique_id = False (bool): If True, a unique id will be generated for the simulation and appended to all generated file name prefixes.
* Hamiltonian coefficients:
    * h_x = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{x,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{x,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * h_y = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{y,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{y,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * h_z = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=h_{z,i}" style="vertical-align:bottom"> coefficient in the Hamiltonian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=h_{z,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * J_z = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=J^z_{ij}" style="vertical-align:bottom"> coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=J^z_{ij}" style="vertical-align:bottom"> for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of <img src="https://render.githubusercontent.com/render/math?math=J" style="vertical-align:bottom"> or <img src="https://render.githubusercontent.com/render/math?math=J_z" style="vertical-align:bottom"> is a matrix, then the other one must be either a matrix as well, or 0.
    * J = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=J_{ij}" style="vertical-align:bottom"> coefficient in the interaction part of the Hamiltonian. If a matrix is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=J_{ij}" style="vertical-align:bottom"> for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice. If either one of <img src="https://render.githubusercontent.com/render/math?math=J" style="vertical-align:bottom"> or <img src="https://render.githubusercontent.com/render/math?math=J_z" style="vertical-align:bottom"> is a matrix, then the other one must be either a matrix as well, or 0.
* Dissipation coefficients:
    * g_0 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{0,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{0,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * g_1 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{1,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{1,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
    * g_2 = 0 (float): The <img src="https://render.githubusercontent.com/render/math?math=g_{2,i}" style="vertical-align:bottom"> coefficient in the Lindbladian. If a vector is given, it specifies <img src="https://render.githubusercontent.com/render/math?math=g_{2,i}" style="vertical-align:bottom"> for each qubit. If a scalar is given, it is uniform for all qubits.
* Initial state:
    The initial state of the simulator is either a pure Pauli product state, a graph state (defined by specifying a set <img src="https://render.githubusercontent.com/render/math?math=V" style="vertical-align:bottom"> of pairs of qubits, to all of which a controlled-Z gate is applied, after initializing all qubits along the positive <img src="https://render.githubusercontent.com/render/math?math=x" style="vertical-align:bottom"> axis) or a saved internal state from previous simulator runs.
    In the case of a pure Pauli stat, the 'init_pauli_state' parameter should be used, in the case of a graph state, the 'init_graph_state' parameter should be used and in the case of a saved internal state the 'load_files_prefix parameter should be used. At each solver object, only one of those parameters should be used and the others should be empty.

    * init_pauli_state = "+z" (list[str]): A length-N vector of two-character strings of the form <img src="https://render.githubusercontent.com/render/math?math=\pm a" style="vertical-align:bottom">. Each string indicates the initial state of qubit <img src="https://render.githubusercontent.com/render/math?math=i" style="vertical-align:bottom">. The initial state will be <img src="https://render.githubusercontent.com/render/math?math=\rho(t_0) = \left|\psi_0\rangle\langle \psi_0\right|" style="vertical-align:bottom">, while <img src="https://render.githubusercontent.com/render/math?math=\left|\psi_0\rangle = \prod_i \right|\pm a_i\rangle" style="vertical-align:bottom">, and the given <img src="https://render.githubusercontent.com/render/math?math=\pm a" style="vertical-align:bottom"> is a Pauli eigenstate: <img src="https://render.githubusercontent.com/render/math?math=\sigma_i^a\left|\pm a_i\rangle = \pm \right|\pm a_i\rangle" style="vertical-align:bottom">. A single such string is also allowed, which will result in an identical initial state for all qubits.
    * init_graph_state = []. A list of integer tuples that specify the qubit pairs for performing a controlled-Z gate on, to generate an initial graph state (starting with all qubits pointing along the +x axis). The qubit pairs will represent j and k in the graph state formula - <img src="https://render.githubusercontent.com/render/math?math=\left|\psi_0\rangle=%20\prod_{(j,k)\in%20V}{CZ}[j,k]%20\prod_i%20\right|%2b%20x_i\rangle" style="vertical-align:bottom">.
    * load_files_prefix = "" (str): The prefix of files as previously saved using the simulator, which the initial state has to be loaded from. An empty string indicates that the initial state is not loaded. See the parameter "b_save_final_state" for more details on the saved files.
* Lattice specification:
    * l_x = 0 (float): The length of the lattice along the x dimension (<img src="https://render.githubusercontent.com/render/math?math=l_x" style="vertical-align:bottom">). In case of value 0, the number of qubits <img src="https://render.githubusercontent.com/render/math?math=N" style="vertical-align:bottom"> is used, and parameter l_y must be 1.
    * l_y = 1 (float): The length of the lattice along the y dimension (<img src="https://render.githubusercontent.com/render/math?math=l_y" style="vertical-align:bottom">).
    * b_periodic_x = False (bool): Whether periodic boundary conditions are applied along the <img src="https://render.githubusercontent.com/render/math?math=x" style="vertical-align:bottom"> dimension. If True, then l_y must be 1. If False, open boundary conditions are used along the <img src="https://render.githubusercontent.com/render/math?math=x" style="vertical-align:bottom"> dimension.
    * b_periodic_y = False (bool): Whether periodic boundary conditions are applied along the <img src="https://render.githubusercontent.com/render/math?math=y" style="vertical-align:bottom"> dimension. If False, open boundary conditions are used along the <img src="https://render.githubusercontent.com/render/math?math=y" style="vertical-align:bottom"> dimension.
* Numerical simulation control:
    * trotter_order = 4 (int): Trotter approximation order, Possible values are 2, 3, 4.
    * max_dim_rho = 400 (int): Maximum bond dimension for density matrices.
    * cut_off_rho = 1e-16 (float): Maximum truncation error (discarded Schmidt weight) for density matrices.
    * b_force_rho_trace = True (bool): Whether to force the density matrix trace to one by substituting <img src="https://render.githubusercontent.com/render/math?math=\rho \to\rho/ {\rm tr}\{\rho\}" style="vertical-align:bottom"> at every time step, compensating for finite-step errors.
    * force_rho_hermitian_step = 4 (int): Determines every how many evolution time steps (<img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom">), to substitute <img src="https://render.githubusercontent.com/render/math?math=\rho \to (\rho %2b \rho^\dagger)/2" style="vertical-align:bottom">. This may reduce some errors, but is computationally expensive.
    * b_initial_rho_compression = True (bool): Whether a density matrix that is loaded from a previously saved state, should be re-gauged and compressed. Has no effect if the initial state is not loaded from a previously saved state.
* Observables and output:
    * 1q_indices = [] (list[int]): A list of integers that specify the qubits which single-qubit observables will be calculated for. In the case of empty list, single-qubit observables will be calculated for all qubits.
    * 1q_components = ['Z'] (list[str]): A list of strings that specify the Pauli observables to compute for all qubits given in parameter "1q_indices". Each string in the list must contain a subset of "x,y,z" (lower or upper case). The observable of a given Pauli <img src="https://render.githubusercontent.com/render/math?math=\sigma^a" style="vertical-align:bottom"> on qubit <img src="https://render.githubusercontent.com/render/math?math=i" style="vertical-align:bottom"> at time <img src="https://render.githubusercontent.com/render/math?math=t_k" style="vertical-align:bottom"> is of the form <img src="https://render.githubusercontent.com/render/math?math=\langle\sigma_i^a(t_k)\rangle" style="vertical-align:bottom">. The observables results are saved using a file name ending with "obs-1q.dat".
    * 2q_indices = [] (list[tuple(int)]): A list of integer tuples that specify the qubit pairs for calculating two-qubit correlators. In the case of empty list, two-qubit correlators will  be calculated for all qubit pairs.
    * 2q_components = ['ZZ'] (list[str]): A list of strings that specify the two-qubit Pauli observables to compute for all qubit pairs given in parameter "2q_indices". Each string in the list must contain a subset of "xx,yy,zz,xy,xz,yz,yx,zx,zy" (lower or upper case). The observable of a given Pauli pair <img src="https://render.githubusercontent.com/render/math?math=\sigma^a" style="vertical-align:bottom"> and <img src="https://render.githubusercontent.com/render/math?math=\sigma^b" style="vertical-align:bottom"> will have the form <img src="https://render.githubusercontent.com/render/math?math=\left\langle \sigma_{i}^a(t_k) \sigma_{j}^b(t_k) \right\rangle" style="vertical-align:bottom">.  The observables results are saved using a file name ending with ".obs-2q.dat".
    * output_step = 1 (int): How often (in discrete steps of time <img src="https://render.githubusercontent.com/render/math?math=\tau" style="vertical-align:bottom">) the observables are computed. In case of value 0, no observables will be computed.
    * b_save_final_state = False (bool): Whether to save the final state to files (Three binary files will be saved, whose names will have the prefix defined in "output_files_prefix").

## Class attributes

* LindbladMPOSolver.parameters: Returns the dict of model parameters.
* LindbladMPOSolver.s_input_file: Returns the path to the configuration file created for the C++ solver.
* LindbladMPOSolver.s_output_path: Returns the path to the output files.
* LindbladMPOSolver.s_cygwin_path: Returns the path to the cygwin executable used by the solver.
* LindbladMPOSolver.s_solver_path: Returns the path to the compiled C++ solver executable file.
* LindbladMPOSolver.s_id_suffix: Returns the solver instance unique id.
* LindbladMPOSolver.result: Returns dict of dicts with the outputs of the solver at all the time steps which an observable was computed. The first dict will contain the one-qubit observable results, the second dict will contain the two-qubit observable results and the third dict will contain global results - the trace of the density matrix, the second Rényi entropy (<img src="https://render.githubusercontent.com/render/math?math=-\ln{(\rm tr }\{\rho^2\})" style="vertical-align:bottom">) and the operator space entanglement entropy (OSEE) for a bipartition at the central bond.

## Class methods

* solve(): Executing the C++ solver and saving the results in "result" attribute.
* process_default_paths(s_cygwin_path (str), s_solver_path (str) -> (str, str): Returns the cygwin and solver paths according to the system platform. keeps them unchanged if given as input.
* build(parameters (dict)): Write the model parameters dictionary to the input configuration file for the C++ solver. Also initializes the s_input_file, s_output_prefix and s_id_suffix attributes according to the given model parameters.
* execute(s_cygwin_path (str), s_solver_path (str), s_input_file (str)) -> int: Executing the C++ solver and returning its C++ exit code.
* load_output(s_output_path (str)) -> dict: Read the solver output files and returns a dictionary with the results.
