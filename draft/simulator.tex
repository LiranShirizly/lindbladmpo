\documentclass[aps,10pt,pra,twocolumn,groupedaddress,floatfix,superscriptaddress,showpacs,showkeys,amsfonts]{revtex4-2}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphics,graphicx}
\graphicspath{{./}}
%\usepackage{psfrag}
\usepackage{epsf}
%\usepackage{epsfig}  
\usepackage{subfigure}
\usepackage[%
  colorlinks=true,
  urlcolor=blue,
  linkcolor=blue,
  citecolor=blue
]{hyperref}
\usepackage[all]{hypcap}
\usepackage{color}
\usepackage[utf8]{inputenc}
%\usepackage{xcolor}
%\usepackage{lscape}
%\allowdisplaybreaks
%\input{./def.tex}
\usepackage{dsfont}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\bea}{\begin{eqnarray}}
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\eq}[1]{Eq.~\eqref{#1}}
\newcommand{\eqs}[1]{Eqs.~\eqref{#1}}
\newcommand{\eqss}[2]{Eqs.~\eqref{#1}-\eqref{#2}}
\newcommand{\seq}[1]{Sec.~\ref{#1}}
\newcommand{\app}[1]{App.~\ref{#1}}
\newcommand{\fig}[1]{Fig.~\ref{#1}}
\newcommand{\figs}[2]{Figs.~\ref{#1}-\ref{#2}}
\newcommand{\bem}{\begin{multline}}
\newcommand{\eem}{\end{multline}}
\newcommand{\new}{\textcolor{red}}

% For one file:
%\newcommand{\apporsm}[1]{the Appendix}
\newcommand{\apporsm}[1]{App.~\ref{#1}}
\newcommand{\appredef}[2]{#2}

% For two files:
%\newcommand{\apporsm}[1]{\cite{Supplemental}}
%\newcommand{\appredef}[2]{#1 (#2)}

\graphicspath{ {figures/} }

%-----------------------------------------------------------
% trick to overwrite the [Your file]Notes.bib created by revtex,
% in order to add the titles

\AtBeginDocument{%
    \newwrite\bibnotes
    \def\bibnotesext{Notes.bib}
    \immediate\openout\bibnotes=\jobname\bibnotesext
    \immediate\write\bibnotes{@CONTROL{REVTEX41Control}}
    \immediate\write\bibnotes{@CONTROL{%
    apsrev41Control,author="08",editor="1",pages="0",title="0",year="1"}}
     \if@filesw
     \immediate\write\@auxout{\string\citation{apsrev41Control}}%
    \fi
}
%
%-----------------------------------------------------------

\begin{document}

\title{A matrix-product-operators simulator of Lindblad dynamics}

\author{Haggai Landa}\email{haggai.landa@ibm.com}
\author{[{\it and...}]}
\affiliation{IBM Quantum, IBM Research Haifa, Haifa University Campus, Mount Carmel, Haifa 31905, Israel}
\author{Gal Shmulovitz}\author{Eldor Fadida}\affiliation{School of Electrical Engineering, Faculty of Engineering, Tel Aviv University, Tel Aviv 69978, Israel}
\author{Grégoire Misguich}\email{gregoire.misguich@ipht.fr}
\affiliation{Institut de Physique Théorique, Université Paris-Saclay, CEA, CNRS, 91191 Gif-sur-Yvette, France}%\affiliation{Laboratoire de Physique Théorique et Modélisation, CNRS UMR 8089, Université de Cergy-Pontoise, 95302 Cergy-Pontoise, France}

\begin{abstract}
\end{abstract}

\maketitle

\section{Introduction}\label{Sec:Intro}
 
\subsection{General background}\label{Sec:Background}

The state of an open quantum system is defined by a density matrix $\rho$. When the system is coupled to a memory-less bath, the time evolution is often described using the master equation
\be
\frac{\partial}{\partial t}\rho = \mathcal{L}[\rho]\equiv -\frac{i}{\hbar}[H,\rho]+\mathcal{D}[\rho],\label{Eq:dtrho}
\ee
where $[\cdot,\cdot]$ is the commutator of two operators, and the notation $\mathcal{L}[\rho]$ implies that the Liouvillian $\mathcal{L}$ is a (linear) superoperator that maps the operator $\rho$ to another operator (in this case, the time derivative of $\rho$). The unitary evolution due to interactions and coherent driving terms is generated by the  (possibly time-dependent) Hamiltonian $H$, while $\mathcal{D}[\rho]$ is a superoperator (sometimes known as the 
dissipator, or Lindbladian) that accounts for incoherent dephasing and relaxation processes due to the environment. 

%The theoretical tools available for open quantum many-body systems are relatively limited, complicated by the fact that the Liouvillian is in general non-Hermitian.

\subsection{Simulator scope}

We introduce a numerical simulator of noisy density-matrix dynamics, specifically Lindbladian dynamics. The solver is based on matrix product states and matrix product operators for the representation of the many-qubit density matrix and its evolution. The solver is written in C++ and uses internally the open source library iTensor \cite{}. The solver integrates the dynamics in fixed time steps $\tau$ up to  the final time $t_f$, using a Trotter expansion of order up to the fourth.

The simulator supports dynamics of qubits described as two-level systems, in a uniform rotating frame (i.e. with fixed coefficients), with arbitrary on-site Hamiltonian parameters, two-qubit interactions [flip-flop (XY) and Ising] on an arbitrary connectivity graph, and three dissipator jump operators ($\sigma^+, \sigma^-, \sigma^z$). It is estimated that a few tens of qubits (20-30) in a `heavy-hex' lattice configuration (as in IBM Quantum Falcon devices) could be simulated in the rotating frame up to times corresponding to the steady state with realistic parameters, on a strong multi-core node. The exact feasible number of qubits depends both on the driving parameters, the dissipation, and the topology. Earlier 1D and 2D simulations using this solver are reported in \cite{bidzhiev_out--equilibrium_2017,bimodality,etatheory}.

In the next version, we will introduce general $d$-level qudit dynamics (suitable for transmon qubits for example), with more general Hamiltonian and Lindbladian parameters, and time-dependence in the parameters (allowing to directly integrate time-dependent drives in the lab frame).

In \seq{Sec:Model} the supported model and its initial state and observables are described. In \app{Sec:Interface} the input and output parameters of the Python interface for the simulator wrapper are described. In \app{Sec:CppInterface} the executable input and output parameters and file formats are specified.

\section{Model}\label{Sec:Model}

\subsection{Lindbladian}
 
 We model $N$ interacting qubits in a planar lattice with an arbitrary connectivity.
The qubits are two-level systems, and we use the Pauli matrices at each site (with the sites indexed by $i$),
\be \sigma_i^a,\qquad a=\{x,y,z\},\ee
and the ladder operators 
\be \sigma^{\pm}_i = {\sigma^{x}_i\pm i\sigma^y_i}/{2}.\ee
%With the common convention for the eigenstates, \be  \left|0\right\rangle = \left|\uparrow\right\rangle, \qquad \left|1\right\rangle = \left|\downarrow\right\rangle,\ee such that $\sigma^z\left|0\right\rangle = \left|0\right\rangle$ and $\sigma^z\left|1\right\rangle = -\left|1\right\rangle$.
The Hamiltonian is defined in the rotating frame with respect to the frequency of an identical drive applied to all qubits (which are not necessarily identical themselves, however, and may be driven at different amplitudes). All parameters defined below are assumed constant in this frame. The details of the lab frame and the transformation are given in \app{App:Frame}.
Decomposing the Hamiltonian in the rotating frame into the sum of on-site terms and the interaction part $T$, we have
\be H/\hbar = \sum_{i}\frac{1}{2}\left[h_{z,i}\sigma_i^z  + h_{x,i}\sigma_i^x + h_{y,i}\sigma_i^y\right] + T.\label{Eq:H0}\ee
%\be H = \sum_{i}\frac{1}{2}\left[{\Delta_i}(1-\sigma_i^z) + \Omega_i\cos\phi_i\sigma_i^x + \Omega_i\sin\phi_i\sigma_i^y\right] + T,\label{Eq:HR}\ee
%Rabi frequency $\Omega_i$, phase $\phi_i$, and detuning $\Delta_i$
%The presence of the identity $\mathds{1}$ in the Hamiltonian does not reflect in the dynamics, but is kept for consistency with the original form of the Hamiltonian in terms of the number operator of a nonlinear oscillator.
with the interaction being 
\bem T = \,-\sum_{ i}^N\sum_{ j\neq i}^N \left(J_{ij}\sigma^+_i \sigma^-_{j} +{\rm h.c.} +\frac{1}{2} J_{ij}^z \sigma^z_i \sigma^z_{j}\right)=\\ -\frac{1}{2}\sum_{ i}^N\sum_{ j\neq i}^N \left(J_{ij}\sigma^x_i \sigma^x_{j} + J_{ij}\sigma^y_i \sigma^y_{j} + J_{ij}^z \sigma^z_i \sigma^z_{j}\right).\label{Eq:Tdef}\end{multline}
We treat three typical dissipator terms in \eq{Eq:dtrho},
\be \mathcal{D} = \sum_j \mathcal{D}_j,\ee
with
\be \mathcal{D}_0[\rho] = \sum_i g_{0,i}\left(\sigma_i^+ \rho\sigma_i^- - \frac{1}{2} \{\sigma_i^- \sigma_i^+,\rho\}\right),\label{Eq:D0}\ee
\be \mathcal{D}_1[\rho]=\sum_i g_{1,i}\left( \sigma_i^-\rho \sigma_i^{+}-\frac{1}{2}\left\{\sigma_i^{+}\sigma_i^-,\rho\right\}\right).\label{Eq:D1}\ee
\be \mathcal{D}_2[\rho] = \sum_i g_{2,i} \left(\sigma_i^z \rho\sigma_i^z - \rho\right),\label{Eq:D2}\ee
 The physical process corresponding to \eqss{Eq:D0}{Eq:D1} is energy exchange with a thermal bath, 
% linear coupling to a thermal bath of Harmonic oscillators at temperature $T$ (with $g_0/g_1= \exp\{-\hbar \omega_z /k_{\rm B}T\}$),
 and \eq{Eq:D2} corresponds to (``pure'') dephasing in $xy$ plane.
%This dissipator takes each spin to its ground state at typical rate $g_{1,i}$.
% and hence for $\Gamma \gg |\Delta|, \Omega, J_{R,R'}$, the unique steady state of the system approaches a pure product state with all spins in their ground state, reached at times $\sim 1/\Gamma$.  

\subsection{Initial state}\label{Sec:InitialState}

The simulator takes as input an initial state that can be a pure Pauli product state,
\be \rho(t=0) = |\psi_0\rangle\langle \psi_0|, \qquad |\psi_0\rangle = \prod_i |\pm a_i\rangle, \ee
with $|\pm a_i\rangle$ a Pauli eigenstate of qubit $i$;
\be \sigma_i^a|\pm a_i\rangle = \pm |\pm a_i\rangle.\ee
In addition, the simulator can also save its internal state representation to a file, and load a saved state to use it as the initial state.

\subsection{Observables}\label{Sec:Observables}


 For the final time $t_f$ and intermediate times $t_k$, the output of the simulator consists of
\begin{enumerate}
\item Time-dependent single-qubit expectation values, \be \left\langle \sigma_i^a\right (t_k)\rangle \label{Eq:mu}.\ee
\item Equal-time two-qubit correlators,
\be \left\langle \sigma_{i}^a(t_k) \sigma_{j}^b(t_k) \right\rangle . \label{Eq:etadef}\ee
\end{enumerate}
These are also referred to as Pauli expectation values (of one and two qubits, respectively), at time $t_k$.

%\bibliographystyle{hunsrt}
\bibliography{simulator}

\appendix

\section{Python Interface}\label{Sec:Interface}

\subsection{Input parameters}\label{Sec:Input}

The solver supports the following parameters as input in the Python interface. If there is a default value, it is given with an equality sign, otherwise it must be specified and an exception is thrown if it is not passed.
\\

\noindent \textbf{Basic parameters}
\begin{enumerate}
\item \verb|N|. The number of qubits in the lattice.
\item \verb|t_final|. The final (total) simulation time, $t_f$.
\item \verb|tau|. The discrete time step $\tau$ for the time evolution.
\item \verb|input_file = `'|. The file name to generate with the input parameters for the executable. If any empty string is given, a temporary system file is allocated and used.
\end{enumerate}

\noindent \textbf{Hamiltonian coefficients}
\begin{enumerate}
\item \verb|h_x = 0|. The $h_{x,i}$ coefficient in \eq{Eq:H0}. If a vector is given, it specifies $h_{x,i}$ for each qubit. If a scalar is given, it is uniform for all qubits.
\item \verb|h_y = 0|. The $h_{y,i}$ coefficient in \eq{Eq:H0}. The syntax and usage are identical to that of \verb|h_x|.
\item \verb|h_z = 0|. The $h_{z,i}$ coefficient in \eq{Eq:H0}. The syntax and usage are identical to that of \verb|h_x|.
\item \verb|J_z = 0|. The $J^z_{ij}$ coefficient in \eq{Eq:Tdef}. If a matrix is given, it specifies $J^z_{ij}$ for each pair of qubits. If a scalar is given, it is uniform for all qubits of a lattice, as specified below.
\item \verb|J = 0|. The $J_{ij}$ coefficient in \eq{Eq:Tdef}. The syntax and usage are identical to that of \verb|J_z|. If either \verb|J| or \verb|J_z| are a matrix, then the other one must be either a matrix as well, or \verb|0|.
\end{enumerate}

\noindent \textbf{Dissipation coefficients}
\begin{enumerate}
\item \verb|g_0 = 0|. The $g_{0,i}$ coefficient in \eq{Eq:D0}. The syntax and usage are identical to that of \verb|h_x|.
\item \verb|g_1 = 1|. The $g_{1,i}$ coefficient in \eq{Eq:D1}.
\item \verb|g_2 = 0|. The $g_{2,i}$ coefficient in \eq{Eq:D2}.
\end{enumerate}

\noindent \textbf{Initial state}
\begin{enumerate}
\item \verb|init_Pauli_state = `+z'|. Either a length-$N$ vector of two-character strings of the form $\pm a$, or a single such string. Each string indicates the initial state of qubit $i$ is a Pauli state as detailed in \seq{Sec:InitialState}, and a single string indicates an identical initial state for all qubits.
\item \verb|load_state_file = `'|. A file name as previously saved using the simulator, to load the initial state from. If this string is nonempty, then \verb|init_Pauli_state| must be an empty string.
\end{enumerate}

\noindent \textbf{Lattice specification}
\\

If both parameters \verb|J| and \verb|J_z| specifying the qubit coupling are scalar (and not a matrix), then the simulator generates a lattice coupling that is specified using the following parameters.

\begin{enumerate}
%\item \verb|cylinder = 0|. If 0, the lattice structure is a chain of all the qubits, else the structure is a cylinder of dimension $l_x \times l_y$.
%\item \verb|periodic = 0|. If 1, periodic boundary conditions in the x direction are used.
\item \verb|l_x = 0|. The length of the lattice along the x dimension ($l_x$). If left at the default 0 value, then the number qubits \verb|N| is used, and \verb|l_y| must take its default value (1) as well.
\item \verb|l_y = 1|. The length of the lattice along the y dimension ($l_y$).  
\item \verb|b_periodic_x = False|. Whether periodic boundary conditions are applied along the x dimension. If True, then \verb|l_y = 1| is required.
\item \verb|b_periodic_y = False|. If True, periodic boundary conditions in the y direction are used.
\end{enumerate}

The supported configurations are a 1D chain or a 2D  rectangular strip (both with open boundary conditions), a 1D ring (with periodic boundary conditions), or a 2D cylinder (with periodic boundary conditions along the y direction).
\\

\noindent \textbf{Numerical simulation control}
\begin{enumerate}

\item \verb|Trotter_order = 4|. Trotter approximation order, Possible values are 2,3,4.

\item \verb|max_dim_rho = 500|. Maximum bond dimension for density matrices.

\item \verb|cut_off_rho = 1e-9|. Maximum truncation error for density matrices.

\item \verb|b_force_rho_trace = True|. Whether the trace of the density matrix be forced to 1 at every time step, irrespective of finite-step errors.

\item \verb|b_force_rho_hermitian = True|. Whether the density matrix be forced to be Hermitian before measuring observables. This is recommended, as it reduces some errors.

\end{enumerate}

\noindent \textbf{Observables and output}
\begin{enumerate}
\item \verb|save_state_file = `'|. A file name where the simulator writes the final state to. Two files will be saved, whose names will be modified by adding the number of qubits to the file name, and using two different extensions.
\item \verb|output_file = `out'|. A file name where the simulator writes the observables to. Possibly two files will be saved, using two different extensions \verb|.1q_obs.dat| and \verb|.2q_obs.dat|, with the single-qubit and two-qubit observables as specified below.
\item \verb|output_step = 1|. How often (in units of \verb|tau|) the observables are computed. For 0 no observables will be computed.
\item \verb|1q_indices = []|. A list of integers that specify the qubits for calculating single-qubit observables as in \eq{Eq:mu}. If left empty it will default to all qubits. 
\item \verb|1q_components = [`X', `Y', `Z']|. A list of strings that specify the Pauli observables to compute for all qubits given in \verb|1q_indices|.
\item \verb|2q_indices = []|. A list of integer tuples that specify the qubit pairs for calculating single-qubit observables as in \eq{Eq:etadef}. If left empty it will default to all qubit pairs.
\item \verb|2q_components = [`XX', `YY', `ZZ']|. A list of strings that specify the two-qubit Pauli observables to compute for all qubits given in \verb|2q_indices|.
%for example:
%\item \verb|1q_sites = [1, 3], 1q_components = ['X','Z'])|
%In this example we compute the pauli expectation value of qubits 1 and 3 on X and Z axis.
%\item \verb|2q_sites = [(1,3),(1,4)]|\\
%\verb|2q_components = ['XX','XZ'])|\\
%In this example we compute the correlation value of qubits (1,3) and (1,4), one time with both qubits projected on X axis and another time with the first on X axis and the second on Z axis. 
\end{enumerate}

\subsection{Call interface}

The solver is exposed using the Python class \verb|MPOLindbladSolver|. The class has the following methods.

%\verb|from ... import MPOSolver|

%\verb|solver = MPOSolver()|

\begin{enumerate}
\item \verb|@staticmethod build_input_file(parameters:|\\ \verb|Dict)|. Build the input file for the solver based on the parameters dictionary.
\item \verb|@staticmethod load_output(s_output_file:|\\ \verb|str) -> Dict|. Load the output file(s) using the given file name, and generate the result dictionary.
\item \verb|@staticmethod execute(s_input_file: str)|. Execute (synchronously) the solver, utilizing the input file parameter.
\item \verb|solve(parameters: Dict)|. This methods combines the generation of an input file for the solver, its synchronous execution, and the construction of the result dictionary. The \verb|parameters| and  \verb|result| dictionaries are stored in class fields for further processing.
\end{enumerate}

\subsection{Result}

The result dictionary stores the output (observables) in the following format;

\begin{enumerate} 

\item \verb|1q_observables: Dict|. A dictionary for the one-qubit observables with the keys being a tuple with the format:
$$ \verb|(qubit: int, Pauli: str, time: float)|. $$
 Each value is the expectation value for the specific key parameters, for example: $$ \verb|{(1, `X', 0): 0, (2, `Z', 0.1): 0.8}|. $$
In this example the result object contains two elements: the Pauli-X expectation value of qubit 1 at time 0 seconds, and the Pauli-Z expectation value for qubit 2 at time 0.1 seconds.
\item \verb|2q_observables: Dict|. A dictionary for the two-qubit observables with the keys being a tuple with the format:
$$ \quad \verb|(qubit, qubit, Pauli: str, time: float)|.$$
  For example:
$$\verb|{(1, 2, `ZZ', 0.1): 0.7}|.$$
In this example the result object contains the Pauli correlation of qubit 1 on the `X' axis and qubit 2 on `Z' axis at time 0.1 seconds.
\end{enumerate}

\section{Solver Executable Interface}\label{Sec:CppInterface}

\subsection{Solver input}

The solver executable accepts a single parameter in its command line, which is the file name of an input file.
In the input file each parameter is specified on a separate line, which contains the parameter name, a space, the equal sign ``='', a space, and a single value or a comma-separated list of values (without spaces).

The parameters that the executable accepts have identical names and meaning as the parameters detailed above for the Python interface, with the following exceptions;
\begin{enumerate} 
\item \verb|J, J_z|. These two executable parameters are passed as a single scalar value (if the Python parameter is scalar), or as a list (no matrix format is supported). If either \verb|J| or \verb|J_z| is a matrix in the Python, then the list consists of all entries which are nonzero in either one of the two matrices. In this case, there are two additional parameters used in order to describe the qubit pairs to which the values correspond:
\item \verb|A_bond_indices, B_bond_indices|. List of the indices of the first and second qubit (respectively) of each entry in the lists \verb|J, J_z| (that must be of identical length).
\end{enumerate}

\subsection{Solver output files}


The solver executable generates up to three files: a saved state (at the simulation end), observables at requested times, and a log file.
The format of the save state file is not described here. The log file is textual. The format of the observable files is detailed below.

\begin{enumerate}
\item The one-qubit observables file is ordered in a table format, in which the headers are: \verb|Component|, \verb|time_t|, \verb|site_i|, \verb|ExpectationValue|. The \verb|Component| is the Pauli operator $\{X,Y,Z\}$, \verb|time_t| is the time that the observable is taken, \verb|site_i| is the qubit index and \verb|ExpectationValue| is the pauli expectation value as in \eq{Eq:mu}. This will be filled row by row, for each time step there will be small tables as the number of qubits, each small table has the specified components ordered by qubit index.

\item The two-qubit observables file is ordered in a table format as well, with headers being: \verb|Component|, \verb|time_t|, \verb|site_i|, \verb|site_j|, \verb|ExpectationValue|. The \verb|Component| is the two specified correlators , \verb|time_t| is the time of the observation, \verb|site_i| is the first qubit index, \verb|site_j| is the second qubit index and \verb|ExpectationValue| is the two qubit pauli correlation value as in \eq{Eq:etadef}. This will be filled row by row, same order as in one qubit file, except each time step table  has all possible combinations of qubits requested.
\end{enumerate}

\section{The lab frame and rotating frame}\label{App:Frame}

TBD.


\end{document}

